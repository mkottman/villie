local AST = ast

module('vlua.translator', package.seeall)

local simpleNode = {Number=true, String=true, Id=true, Dots="...", True="true", False="false", Nil="nil"}
function isSimpleNode(tag)
	return simpleNode[tag]
end

-- very ugly
local globGraph

updaters = {
	Set = function (self)
		local v = self.nodes.target
		local val = self.nodes.value
		self.value = v.value .. ' = ' .. val.value
	end,
	Local = function(self)
		local l = self.nodes.defines
		local val = self.nodes.value
		self.value = "local " .. l.value
		if val then self.value = self.value .. " = " .. val.value end
	end,
	If = function (self)
		local cond = self.nodes.condition
		local body = self.nodes.body
		local els = self.nodes["else"]
		self.value = cond.value
		body.edges["do"].title = 'if ' .. cond.value
		if els then els.edges["do"].title = 'else' end
	end,
	Fornum = function(self)
		local var = self.nodes.variable
		local from = self.nodes.from
		local to = self.nodes.to
		local body = self.nodes.body
		self.value = 'for ' .. var.value .. ' = ' .. from.value .. ', ' .. to.value
		body.edges["do"].title = 'Variable: '..var.value
	end,
	Forin = function(self)
		local var = self.nodes.variable
		local exp = self.nodes.iterator
		local body = self.nodes.body
		self.value = 'for ' .. var.value .. ' in ' .. exp.value
		body.edges["do"].title = 'Variable: '..var.value
	end,
	While = function(self)
		local cond = self.nodes.condition
		local body = self.nodes.body
		self.value = 'while ' .. cond.value
		body.edges["do"].title = 'while ' .. cond.value
	end,
	Repeat = function(self)
		local cond = self.nodes["until"]
		local body = self.nodes.body
		self.value = 'until ' .. cond.value
		body.edges["do"].title = 'until ' .. cond.value
	end,
	Return = function(self)
		local exp = self.nodes.returns
		self.value = 'return'
		if exp then self.value = self.value .. ' ' .. exp.value end
	end,
	Call = function(self)
		local func = self.nodes["function"]
		local args = List()
		if not self.count then self.count = 0 end
		for i=1,self.count do
			trace("Updating %d / %d", i, self.count)
			args:append(self.nodes["arg"..i].value)
		end
		self.value = func.value .. '('..table.concat(args, ', ')..')'
	end,
	Invoke = function(self)
		local obj = self.nodes.object
		local func = self.nodes.method
		local args = List()
		if not self.count then self.count = 0 end
		for i=1,self.count do
			args:append(self.nodes["arg"..i].value)
		end
		self.value = obj.value .. ':' .. func.value:gsub('"','') .. '('..table.concat(args, ', ')..')'
	end,
	Funcdef = function (self)
		local nm = self.nodes.name
		local name = nm.value
		local graph = globGraph or gui.view.graph

		trace(STR, graph, repr(graph.elements, 'elements'))

		-- rename in scene elements
		if nm.oldvalue and nm.oldvalue ~= name then
			trace('Renaming element %s to %s', nm.oldname, name)
			local func = graph.elements[nm.oldvalue]
			graph.elements[nm.oldvalue] = nil
			graph.elements[name] = func
			nm.oldvalue = name
			if gui.view.graph then gui.view:updateElements() end
		end

		trace('Retrieving function %s', name)
		local func = graph.elements[name]

		-- construct argument list
		local body = func.nodes.body
		local args = List()
		for i=1,func.count do
			args:append(func.nodes["arg"..i].value)
		end
		
		args = table.concat(args, ', ')
		body.edges["do"].title = 'Arguments: ' .. args
		
		args = '(' .. args .. ')'
		
		func.value = name .. args
		self.value = name .. args
	end,
	Function = function(self)
		local def = self.funcdef
		def:update()
	end
}


--- Translates a Lua AST <code>ast</code> to graph model. Fills <code>graph</code>
-- with appropriate nodes, edges and incidences. Also resolves references between
-- variables. Function definitions are handled as separate graph elements, indexed
-- by their name. Anonymous functions are handled as expressions.
-- Currently does not handle multiple assignment.
-- @param ast Lua AST generated by the <code>ast</code> module.
-- @param graph Graph, which should be filled.
function fromAst(ast, graph)
	local processBlock, processExpression, processStatement, handleFunctionDefinition
	local currentBlock

	function handleFunctionDefinition(s)
		if s.tag == "Set" and s[1] and s[2] and #s[1] == 1 and #s[2] == 1 and s[2][1].tag == "Function"
		or s.tag == "Localrec" and #s == 2 and s[2][1].tag == "Function" and s[1][1].tag == "Id"
		then
			local f = s[2][1]
			local name = AST.decompile(s[1][1])
			local func = graph:createEdge("Function")
			local args = {}
			for i,a in ipairs(f[1]) do
				local arg = processExpression(a)
				graph:connect(arg, func, "arg"..i, "in")
				args[i] = AST.decompile(a)
			end
			func.count = #f[1]

			local body = processBlock(f[#f], currentBlock)
			graph:connect(body, func, "body", "out")
			
			trace('Creating element %s with value %s', name, tostring(func))
			graph.elements[name] = func

			local funcdef = graph:createEdge("Funcdef")
			func.funcdef = funcdef
			
			local nm = graph:createNode("Expression")
			nm.value = name
			nm.oldvalue = name
			graph:connect(nm, funcdef, "name", "in")

			funcdef.update = updaters.Funcdef
			funcdef:update()

			local ndo = graph:createNode("Stat")
			graph:connect(ndo, funcdef, "do", "in")
			return ndo
		end
	end

	function processStatement(s)
		local tag = s.tag
		if not tag then error(STR("Error in processing statement", repr(s))) end
		
		local funcdef = handleFunctionDefinition(s)
		if funcdef then return funcdef end
		
		local edge
		if tag == "Set" or tag == "Local" then
			edge = graph:createEdge(tag)
			
			if math.max(#s[1], #s[2]) > 1 then
				fatal("Unable to parse multiple assignment: %s", AST.decompile(s))
			else
				local var = s[1][1][1]
				if tag == "Local" then
					local l = graph:createNode("Expression")
					l.value = var
					graph:connect(l, currentBlock.nodes.info.edges.locals, var, "out")
					graph:connect(l, edge, "defines", "out")
					local val
					if s[2][1] then
						val = processExpression(s[2][1])
						graph:connect(val, edge, "value", "in")
					end
				else
					local v = processExpression(s[1][1])
					local val = processExpression(s[2][1])
					graph:connect(v, edge, "target", "out")
					graph:connect(val, edge, "value", "in")
				end
			end
		elseif tag == "If" then
			edge = graph:createEdge(tag)
			if #s > 3 then
				fatal("Unable to parse elseif blocks")
			else
				local cond = processExpression(s[1])
				local body = processBlock(s[2], currentBlock)

				graph:connect(cond, edge, "condition", "in")
				graph:connect(body, edge, "body", "out")
				
				if #s == 3 then
					local els = processBlock(s[3], currentBlock)
					graph:connect(els, edge, "else", "out")
				end
			end
		elseif tag == "Fornum" then
			edge = graph:createEdge(tag)
			local var = processExpression(s[1])
			local from = processExpression(s[2])
			local to = processExpression(s[3])
			local body = processBlock(s[#s], currentBlock)
			graph:connect(var, edge, "variable", "in")
			graph:connect(from, edge, "from", "in")
			graph:connect(to, edge, "to", "in")
			graph:connect(body, edge, "body", "out")
		elseif tag == "Forin" then
			edge = graph:createEdge(tag)
			local var = processExpression(s[1][1])
			local exp = processExpression(s[2][1])
			local body = processBlock(s[3])
			graph:connect(var, edge, "variable", "in")
			graph:connect(exp, edge, "iterator", "in")
			graph:connect(body, edge, "body", "out")
		elseif tag == "While" then
			edge = graph:createEdge(tag)
			local cond = processExpression(s[1])
			local body = processBlock(s[2], currentBlock)
			graph:connect(cond, edge, "condition", "in")
			graph:connect(body, edge, "body", "out")
		elseif tag == "Repeat" then
			edge = graph:createEdge(tag)
			local body = processBlock(s[1], currentBlock)
			local cond = processExpression(s[2])
			graph:connect(body, edge, "body", "out")
			graph:connect(cond, edge, "until", "in")
		elseif tag == "Return" then
			edge = graph:createEdge(tag)
			local exp
			if s[1] then
				exp = processExpression(s[1])
				graph:connect(exp, edge, "returns", "in")
			end
		elseif tag == "Break" then
			edge = graph:createEdge(tag)
			edge.value = "Break"
		elseif tag == "Call" then
			edge = graph:createEdge(tag)
			local func = processExpression(s[1])
			graph:connect(func, edge, "function", "in")
			for i=2,#s do
				local arg = processExpression(s[i])
				graph:connect(arg, edge, "arg"..(i-1), "in")
			end
			edge.count = #s - 1
		elseif tag == "Invoke" then
			edge = graph:createEdge(tag)
			local obj = processExpression(s[1])
			local func = processExpression(s[2])
			graph:connect(obj, edge, "object", "in")
			graph:connect(func, edge, "method", "in")
			for i=3,#s do
				local arg = processExpression(s[i])
				graph:connect(arg, edge, "arg"..(i-2), "in")
			end
			edge.count = #s - 2
		else
			fatal("Unhandled statement %s", tag)
			edge = graph:createEdge("Unknown")
		end
		
		if updaters[tag] then edge.update = updaters[tag] end
		if edge.update then edge:update() end
		
		local ndo = graph:createNode("Stat")
		graph:connect(ndo, edge, "do", "in")
		return ndo
	end
	
	local function resolveIds(exp, node, block)
		local function resolve(id, inBlock)
			for i,n in pairs(inBlock.nodes.info.edges["locals"].nodes) do
				if id == i.name then
					local e = graph:createEdge("Ref")
					graph:connect(node, e, "references", "in")
					graph:connect(n, e, "variable", "out")
					return
				end
			end
			if inBlock.parent then return resolve(id, inBlock.parent) end
		end
		local function findIds(inExp)
			if inExp.tag == "Id" then
				local id = inExp[1]
				resolve(id, block)
			else
				for _,e in ipairs(inExp) do
					if type(e) == "table" then findIds(e) end
				end
			end
		end
		findIds(exp)
	end
	
	function processExpression(e)
		local n = graph:createNode("Expression")
		resolveIds(e, n, currentBlock)
		n.value = AST.decompile(e)
		return n
	end

	function processBlock(b, parent)
		local ndo = graph:createNode("Stat")
		local block = graph:createEdge("Block")
		graph:connect(ndo, block, "do", "in")
		
		local oldBlock = currentBlock
		currentBlock = block
		block.parent = parent

		local info = graph:createNode("Info")
		graph:connect(info, block, "info", "out")
		local locals = graph:createEdge("Locals")
		graph:connect(info, locals, "locals", "in")
		
		local last
		local count = 0
		for i=1, #b do
			local s = processStatement(b[i])
			if s then
				count = count + 1
				graph:connect(s, block, tostring(count), "out")
				if last then
					graph:connect(s, last.edges["do"], "next", "out")
				end
				last = s
			end
		end
		block.count = count
		currentBlock = oldBlock
		
		return ndo
	end

	-- temporary global
	globGraph = graph
	local main = processBlock(ast)
	main.edges["do"].title = 'Main program'
	graph.elements.__Main = main.edges["do"]
	globGraph = nil
end

--- Translates graph back to Lua AST, so that it can be converted to Lua using ast.decompile.
-- @param graph Graph, whose element __Main will be translated as main program
-- @return resulting AST
function toAst(graph)
	local toBlock, toExpression, toStatement
	
	function toExpression(exp)
		if exp.type.name == "Expression" then
			assert(exp.value, "expression doesn't have value!")
			local res = ast.compile(tostring(exp.value), true)
			return res
		else
			local res = {}
			res.tag = exp.type.name
			res[1] = exp.value
			return res
		end
	end
	
	function toStatement(stat)
		local res = {}
		stat = stat.edges["do"]
		local tag = stat.type.name
		
		res.tag = tag
		
		if tag == "Set" then
			print(repr(stat, "Set", {maxlevel=4}))
			res[1] = {toExpression(stat.nodes["target"])}
			res[2] = {toExpression(stat.nodes["value"])}
		elseif tag == "Local" then
			res[1] = {toExpression(stat.nodes["defines"])}
			res[2] = {}
			if stat.nodes["value"].value ~= "" then
				res[2][1] = toExpression(stat.nodes["value"])
			end
		elseif tag == "If" then
			local cond = toExpression(stat.nodes["condition"])
			local body = toBlock(stat.nodes["body"].edges["do"])
			res[1] = cond
			res[2] = body
		elseif tag == "While" then
			local cond = toExpression(stat.nodes["condition"])
			local body = toBlock(stat.nodes["body"].edges["do"])
			res[1] = cond
			res[2] = body
		elseif tag == "Repeat" then
			local body = toBlock(stat.nodes["body"].edges["do"])
			local cond = toExpression(stat.nodes["until"])
			res[1] = body
			res[2] = cond
		elseif tag == "Call" then
			local func = toExpression(stat.nodes["function"])
			res[1] = func
			for i = 1, stat.count do
				local arg = toExpression(stat.nodes["arg"..i])
				res[i+1] = arg
			end
		elseif tag == "Invoke" then
			local obj = toExpression(stat.nodes["object"])
			local met = toExpression(stat.nodes["method"])
			res[1] = obj
			res[2] = met
			for i = 1, stat.count do
				local arg = toExpression(stat.nodes["arg"..i])
				res[i+2] = arg
			end
		elseif tag == "Break" then
			-- done
		elseif tag == "Return" then
			local exp = toExpression(stat.nodes["returns"])
			res[1] = exp
		elseif tag == "Fornum" then
			local var = toExpression(stat.nodes["variable"])
			local from = toExpression(stat.nodes["from"])
			local to = toExpression(stat.nodes["to"])
			local body = toBlock(stat.nodes["body"].edges["do"])
			res[1] = var
			res[2] = from
			res[3] = to
			res[4] = body
		elseif tag == "Forin" then
			res[1] = {toExpression(stat.nodes["variable"])}
			res[2] = {toExpression(stat.nodes["iterator"])}
			res[3] = toBlock(stat.nodes["body"].edges["do"])
		elseif tag == "Funcdef" then
			local name = stat.nodes["name"].value
			local func = graph.elements[name]
			res.tag = "Set"
			res[1] = {{tag="Id", name}}
			res[2] = {{tag="Function", {}}}
			for i=1, func.count do
				local arg = toExpression(func.nodes["arg"..i])
				res[2][1][1][i] = arg
			end
			res[2][1][2] = toBlock(func.nodes["body"].edges["do"])
		else
			fatal("toAst: unknown tag: %s", tag)
		end
		
		return res
	end
	
	function toBlock(block)
		local b = {}
		for i=1,block.count do
			table.insert(b, toStatement(block.nodes[tostring(i)]))
		end
		return b
	end
	
	local ast = toBlock(graph.elements.__Main)
	return ast
end
