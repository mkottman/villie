local AST = ast

module('vlua.translator', package.seeall)

local simpleNode = {Number=true, String=true, Id=true, Dots="...", True="true", False="false", Nil="nil"}
function isSimpleNode(tag)
	return simpleNode[tag]
end

--- Translates a Lua AST <code>ast</code> to graph model. Fills <code>graph</code>
-- with appropriate nodes, edges and incidences. Also resolves references between
-- variables. Function definitions are handled as separate graph elements, indexed
-- by their name. Anonymous functions are handled as expressions.
-- Currently does not handle multiple assignment.
-- @param ast Lua AST generated by the <code>ast</code> module.
-- @param graph Graph, which should be filled.
function translate(ast, graph)
	local processBlock, processExpression, processStatement, handleFunctionDefinition
	local currentBlock

	function handleFunctionDefinition(s)
		if s.tag == "Set" and s[1] and s[2] and #s[1] == 1 and #s[2] == 1 and s[2][1].tag == "Function"
		or s.tag == "Localrec" and #s == 2 and s[2][1].tag == "Function" and s[1][1].tag == "Id"
		then
			local f = s[2][1]
			local name = AST.decompile(s[1][1])
			local func = graph:createEdge("Function")
			local args = {}
			for i,a in ipairs(f[1]) do
				local arg = processExpression(a)
				graph:connect(arg, func, "arg"..i, "in")
				args[i] = AST.decompile(a)
			end
			func.count = #f[1]

			local body = processBlock(f[#f], currentBlock)
			graph:connect(body, func, "body", "out")
			
			graph.elements[name] = func
			
			body.edges["do"].title = name .. ' : ' .. table.concat(args, ', ')
			
			local funcdef = graph:createEdge("Funcdef")
			local nm = graph:createNode("Id")
			nm.value = name
			graph:connect(nm, funcdef, "name", "in")

			funcdef.value = name
			local ndo = graph:createNode("Stat")
			graph:connect(ndo, funcdef, "do", "in")
			return ndo
		end
	end

	function processStatement(s)
		local tag = s.tag
		if not tag then error(STR("Error in processing statement", repr(s))) end
		
		local funcdef = handleFunctionDefinition(s)
		if funcdef then return funcdef end
				
		local edge
		if tag == "Set" or tag == "Local" then
			edge = graph:createEdge(tag)
			local value = {}
			
			if math.max(#s[1], #s[2]) > 1 then
				fatal("Unable to parse multiple assignment: %s", AST.decompile(s))
			else
				local var = s[1][1][1]
				if tag == "Local" then
					local l = graph:createNode("Id")
					l.value = var
					graph:connect(l, currentBlock.nodes.info.edges.locals, var, "out")
					graph:connect(l, edge, "defines", "out")
				else
					local v = processExpression(s[1][1])
					local val = processExpression(s[2][1])
					graph:connect(v, edge, "target", "out")
					graph:connect(val, edge, "value", "in")
				end
				
				edge.value = AST.decompile(s)
			end
		elseif tag == "If" then
			edge = graph:createEdge(tag)
			if #s > 3 then
				fatal("Unable to parse elseif blocks")
			else
				local cond = processExpression(s[1])
				local body = processBlock(s[2], currentBlock)

				graph:connect(cond, edge, "condition", "in")
				graph:connect(body, edge, "body", "out")
				
				if #s == 3 then
					local els = processBlock(s[3], currentBlock)
					graph:connect(els, edge, "else", "out")
				end
				
				edge.value = AST.decompile(s[1])
			end
		elseif tag == "Fornum" then
			edge = graph:createEdge(tag)
			local var = processExpression(s[1])
			local from = processExpression(s[2])
			local to = processExpression(s[3])
			local body = processBlock(s[4], currentBlock)
			graph:connect(var, edge, "variable", "in")
			graph:connect(from, edge, "from", "in")
			graph:connect(to, edge, "to", "in")
			graph:connect(body, edge, "body", "out")
		elseif tag == "Forin" then
			edge = graph:createEdge(tag)
			local vars = {}
			for i,v in ipairs(s[1]) do
				local var = processExpression(v)
				vars[i] = v[1]
				graph:connect(var, edge, "var"..i, "in")
			end
			edge.count = #s[1]
			
			local exp = processExpression(s[2][1])
			graph:connect(exp, edge, "iterator", "in")
			local body = processBlock(s[3])
			graph:connect(body, edge, "body", "out")
			
			edge.value = trim(table.concat(vars, ', ') .. ' in ' .. AST.decompile(s[2]))
		elseif tag == "While" then
			edge = graph:createEdge(tag)
			local cond = processExpression(s[1])
			local body = processBlock(s[2], currentBlock)
			graph:connect(cond, edge, "condition", "in")
			graph:connect(body, edge, "body", "out")
			edge.value = AST.decompile(s[1])
		elseif tag == "Repeat" then
			edge = graph:createEdge(tag)
			local body = processBlock(s[1], currentBlock)
			local cond = processExpression(s[2])
			graph:connect(body, edge, "body", "out")
			graph:connect(cond, edge, "until", "in")
		elseif tag == "Return" then
			edge = graph:createEdge(tag)
			local exp = processExpression(s[1])
			graph:connect(exp, edge, "returns", "in")
			edge.value = AST.decompile(s[1])
		elseif tag == "Break" then
			edge = graph:createEdge(tag)
		elseif tag == "Call" then
			edge = graph:createEdge(tag)
			local func = processExpression(s[1])
			graph:connect(func, edge, "function", "in")
			for i=2,#s do
				local arg = processExpression(s[i])
				graph:connect(arg, edge, "arg"..(i-1), "in")
			end
			edge.count = #s - 1
			edge.value = AST.decompile(s):sub(1, -2)
		elseif tag == "Invoke" then
			edge = graph:createEdge(tag)
			local obj = processExpression(s[1])
			local func = processExpression(s[2])
			graph:connect(obj, edge, "object", "in")
			graph:connect(func, edge, "method", "in")
			for i=3,#s do
				local arg = processExpression(s[i])
				graph:connect(arg, edge, "arg"..(i-2), "in")
			end
			edge.count = #s - 2
			edge.value = AST.decompile(s):sub(1, -3)
		else
			fatal("Unhandled statement %s", tag)
			edge = graph:createEdge("Unknown")
		end
		
		local ndo = graph:createNode("Stat")
		graph:connect(ndo, edge, "do", "in")
		return ndo
	end
	
	local function resolveIds(exp, node, block)
		local function resolve(id, inBlock)
			for i,n in pairs(inBlock.nodes.info.edges["locals"].nodes) do
				if id == i.name then
					local e = graph:createEdge("Ref")
					graph:connect(node, e, "refereces", "in")
					graph:connect(n, e, "variable", "out")
					return
				end
			end
			if inBlock.parent then return resolve(id, inBlock.parent) end
		end
		local function findIds(inExp)
			if inExp.tag == "Id" then
				local id = inExp[1]
				resolve(id, block)
			else
				for _,e in ipairs(inExp) do
					if type(e) == "table" then findIds(e) end
				end
			end
		end
		findIds(exp)
	end
	
	function processExpression(e)
		local tag = e.tag
		if not tag then error(STR("Error in processing expression", repr(e))) end
		local simple = isSimpleNode(tag)
		if simple then
			local n = graph:createNode(tag)
			n.value = type(simple) == "string" and simple or e[1]
			return n
		else
			local n = graph:createNode("Expression")
			resolveIds(e, n, currentBlock)
			n.value = AST.decompile(e)
			return n
		end
	end

	function processBlock(b, parent)
		local ndo = graph:createNode("Stat")
		local block = graph:createEdge("Block")
		graph:connect(ndo, block, "do", "in")
		
		local oldBlock = currentBlock
		currentBlock = block
		block.parent = parent

		local info = graph:createNode("Info")
		graph:connect(info, block, "info", "out")
		local locals = graph:createEdge("Locals")
		graph:connect(info, locals, "locals", "in")
		
		local last
		local count = 0
		for i=1, #b do
			local s = processStatement(b[i])
			if s then
				count = count + 1
				graph:connect(s, block, tostring(count), "out")
				if last then
					graph:connect(s, last.edges["do"], "next", "out")
				end
				last = s
			end
		end
		block.count = count
		currentBlock = oldBlock
		
		return ndo
	end

	local main = processBlock(ast)
	io.open('ast', 'w'):write(repr(ast, 'ast', {maxlevel=999}))
	graph.ast = ast
	graph.elements.__Main = main.edges["do"]
end


--- Translates graph back to Lua AST, so that it can be converted to Lua using ast.decompile.
-- @param graph Graph, whose element __Main will be translated as main program
-- @return resulting AST
function toAst(graph)
	local toBlock, toExpression, toStatement
	
	function toExpression(exp)
		if exp.type.name == "Expression" then
			assert(exp.value, "expression doesn't have value!")
			return ast.compile(exp.value, true)
		else
			local res = {}
			res.tag = exp.type.name
			res[1] = exp.value
			return res
		end
	end
	
	function toStatement(stat)
		local res = {}
		stat = stat.edges["do"]
		local tag = stat.type.name
		
		res.tag = tag
		
		if tag == "Set" or tag == "Local" then
			res = ast.compile(stat.value)[1]
		elseif tag == "If" then
			local cond = toExpression(stat.nodes["condition"])
			local body = toBlock(stat.nodes["body"].edges["do"])
			res[1] = cond
			res[2] = body			
		elseif tag == "While" then
			local cond = toExpression(stat.nodes["condition"])
			local body = toBlock(stat.nodes["body"].edges["do"])
			res[1] = cond
			res[2] = body
		elseif tag == "Repeat" then
			local body = toBlock(stat.nodes["body"].edges["do"])
			local cond = toExpression(stat.nodes["until"])
			res[1] = body
			res[2] = cond
		elseif tag == "Call" then
			local func = toExpression(stat.nodes["function"])
			res[1] = func
			for i = 1, stat.count do
				local arg = toExpression(stat.nodes["arg"..i])
				res[i+1] = arg
			end
		elseif tag == "Invoke" then
			local obj = toExpression(stat.nodes["object"])
			local met = toExpression(stat.nodes["method"])
			res[1] = obj
			res[2] = met
			for i = 1, stat.count do
				local arg = toExpression(stat.nodes["arg"..i])
				res[i+2] = arg
			end
		elseif tag == "Break" then
			-- done
		elseif tag == "Return" then
			local exp = toExpression(stat.nodes["returns"])
			res[1] = exp
		elseif tag == "Fornum" then
			local var = toExpression(stat.nodes["variable"])
			local from = toExpression(stat.nodes["from"])
			local to = toExpression(stat.nodes["to"])
			local body = toBlock(stat.nodes["body"].edges["do"])
			res[1] = var
			res[2] = from
			res[3] = to
			res[4] = body
		elseif tag == "Forin" then
			res[1] = {}
			for i=1,stat.count do
				res[1][i] = toExpression(stat.nodes["var"..i])
			end
			res[2] = {toExpression(stat.nodes["iterator"])}
			res[3] = toBlock(stat.nodes["body"].edges["do"])
		elseif tag == "Funcdef" then
			local name = stat.value
			local func = graph.elements[name]
			res.tag = "Set"
			res[1] = {{tag="Id", name}}
			res[2] = {{tag="Function", {}}}
			for i=1, func.count do
				local arg = toExpression(func.nodes["arg"..i])
				res[2][1][1][i] = arg
			end
			res[2][1][2] = toBlock(func.nodes["body"].edges["do"])
		else
			fatal("toAst: unknown tag: %s", tag)
		end
		
		return res
	end
	
	function toBlock(block)
		local b = {}
		for i=1,block.count do
			table.insert(b, toStatement(block.nodes[tostring(i)]))
		end
		return b
	end
	
	local ast = toBlock(graph.elements.__Main)
	print(repr(ast, 'ast', {maxlevel=999}))
	return ast
end
